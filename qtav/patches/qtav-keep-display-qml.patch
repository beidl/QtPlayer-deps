diff --git a/qml/QmlAV/QmlAVPlayer.h b/qml/QmlAV/QmlAVPlayer.h
index 9e83391..7ff8235 100644
--- a/qml/QmlAV/QmlAVPlayer.h
+++ b/qml/QmlAV/QmlAVPlayer.h
@@ -248,6 +248,7 @@ public Q_SLOTS:
     void seek(int offset);
     void seekForward();
     void seekBackward();
+    void prebuffer();
 
 Q_SIGNALS:
     void volumeChanged();
@@ -285,6 +286,7 @@ Q_SIGNALS:
     void externalAudioTracksChanged();
     void internalSubtitleTrackChanged();
     void internalSubtitleTracksChanged();
+    void bufferingFinished();
 
     void errorChanged();
     void error(Error error, const QString &errorString);
@@ -298,6 +300,7 @@ private Q_SLOTS:
     void _q_started();
     void _q_stopped();
     void _q_paused(bool);
+    void _q_prebuffer(QtAV::MediaStatus status);
 
 private Q_SLOTS:
     void applyVolume();
diff --git a/qml/QmlAVPlayer.cpp b/qml/QmlAVPlayer.cpp
index 7382974..b1e1be0 100644
--- a/qml/QmlAVPlayer.cpp
+++ b/qml/QmlAVPlayer.cpp
@@ -74,6 +74,11 @@ void QmlAVPlayer::classBegin()
     if (mpPlayer)
         return;
     mpPlayer = new AVPlayer(this);
+    mpPlayer->setMediaEndAction(MediaEndAction_KeepDisplay);
+    mpPlayer->setAsyncLoad(true);
+
+    //connect(mpPlayer, SIGNAL(mediaStatusChanged(QtAV::MediaStatus)), this, SLOT(_q_prebuffer(QtAV::MediaStatus)), Qt::DirectConnection);
+    connect(mpPlayer, SIGNAL(bufferingFinished()), this, SIGNAL(bufferingFinished()), Qt::DirectConnection);
     connect(mpPlayer, SIGNAL(internalSubtitleTracksChanged(QVariantList)), SIGNAL(internalSubtitleTracksChanged()));
     connect(mpPlayer, SIGNAL(internalAudioTracksChanged(QVariantList)), SIGNAL(internalAudioTracksChanged()));
     connect(mpPlayer, SIGNAL(externalAudioTracksChanged(QVariantList)), SIGNAL(externalAudioTracksChanged()));
@@ -850,6 +855,20 @@ void QmlAVPlayer::_q_stopped()
     Q_EMIT playbackStateChanged();
 }
 
+void QmlAVPlayer::prebuffer()
+{
+    _q_prebuffer(QtAV::MediaStatus::LoadedMedia);
+}
+
+void QmlAVPlayer::_q_prebuffer(QtAV::MediaStatus status)
+{
+    qDebug() << Q_FUNC_INFO;
+    if (status == QtAV::MediaStatus::LoadedMedia) {
+        qDebug() << "PREBUFFER!";
+        this->mpPlayer->prebuffer();
+    }
+}
+
 void QmlAVPlayer::applyVolume()
 {
     AudioOutput *ao = mpPlayer->audio();
diff --git a/src/AVDemuxThread.cpp b/src/AVDemuxThread.cpp
index 84aa526..36d3858 100644
--- a/src/AVDemuxThread.cpp
+++ b/src/AVDemuxThread.cpp
@@ -334,6 +334,10 @@ void AVDemuxThread::updateBufferState()
     if (m_buffering == m_buffer->isBuffering())
         return;
     m_buffering = m_buffer->isBuffering();
+    if (!m_buffering) {
+        qDebug() << "FR3DL: baffad";
+        Q_EMIT bufferingFinished();
+    }
     Q_EMIT mediaStatusChanged(m_buffering ? QtAV::BufferingMedia : QtAV::BufferedMedia);
     // state change to buffering, report progress immediately. otherwise we have to wait to read 1 packet.
     if (m_buffering) {
diff --git a/src/AVDemuxThread.h b/src/AVDemuxThread.h
index 3a400fc..f6b59a8 100644
--- a/src/AVDemuxThread.h
+++ b/src/AVDemuxThread.h
@@ -62,6 +62,7 @@ Q_SIGNALS:
     void requestClockPause(bool value);
     void mediaStatusChanged(QtAV::MediaStatus);
     void bufferProgressChanged(qreal);
+    void bufferingFinished();
     void seekFinished(qint64 timestamp);
     void stepFinished();
     void internalSubtitlePacketRead(int index, const QtAV::Packet& packet);
diff --git a/src/AVPlayer.cpp b/src/AVPlayer.cpp
index 417e3eb..160fdf5 100644
--- a/src/AVPlayer.cpp
+++ b/src/AVPlayer.cpp
@@ -84,11 +84,13 @@ AVPlayer::AVPlayer(QObject *parent) :
     connect(&d->demuxer, SIGNAL(loaded()), this, SIGNAL(loaded()));
     connect(&d->demuxer, SIGNAL(seekableChanged()), this, SIGNAL(seekableChanged()));
     d->read_thread = new AVDemuxThread(this);
+
     d->read_thread->setDemuxer(&d->demuxer);
     //direct connection can not sure slot order?
     connect(d->read_thread, SIGNAL(finished()), this, SLOT(stopFromDemuxerThread()), Qt::DirectConnection);
     connect(d->read_thread, SIGNAL(requestClockPause(bool)), masterClock(), SLOT(pause(bool)), Qt::DirectConnection);
     connect(d->read_thread, SIGNAL(mediaStatusChanged(QtAV::MediaStatus)), this, SLOT(updateMediaStatus(QtAV::MediaStatus)));
+    connect(d->read_thread, SIGNAL(bufferingFinished()), this, SIGNAL(bufferingFinished()));
     connect(d->read_thread, SIGNAL(bufferProgressChanged(qreal)), this, SIGNAL(bufferProgressChanged(qreal)));
     connect(d->read_thread, SIGNAL(seekFinished(qint64)), this, SLOT(onSeekFinished(qint64)), Qt::DirectConnection);
     connect(d->read_thread, SIGNAL(internalSubtitlePacketRead(int, QtAV::Packet)), this, SIGNAL(internalSubtitlePacketRead(int, QtAV::Packet)), Qt::DirectConnection);
@@ -111,6 +113,103 @@ AVPlayer::~AVPlayer()
     }
 }
 
+void AVPlayer::prebuffer()
+{
+    QMutexLocker lock(&d->load_mutex);
+    Q_UNUSED(lock);
+    if (!d->demuxer.isLoaded())
+            return;
+
+    d->start_position_norm = normalizedPosition(d->start_position);
+    d->stop_position_norm = normalizedPosition(d->stop_position);
+    // FIXME: if call play() frequently playInternal may not be called if disconnect here
+    disconnect(this, SIGNAL(loaded()), this, SLOT(playInternal()));
+    if (!d->setupAudioThread(this)) {
+        d->read_thread->setAudioThread(0); //set 0 before delete. ptr is used in demux thread when set 0
+        if (d->athread) {
+            qDebug("release audio thread.");
+            delete d->athread;
+            d->athread = 0;//shared ptr?
+        }
+    }
+    if (!d->setupVideoThread(this)) {
+        d->read_thread->setVideoThread(0); //set 0 before delete. ptr is used in demux thread when set 0
+        if (d->vthread) {
+            qDebug("release video thread.");
+            delete d->vthread;
+            d->vthread = 0;//shared ptr?
+        }
+    }
+    if (!d->athread && !d->vthread) {
+        d->loaded = false;
+        qWarning("load failed");
+        return;
+    }
+    // setup clock before avthread.start() becuase avthreads use clock. after avthreads setup because of ao check
+    masterClock()->reset();
+    // TODO: add isVideo() or hasVideo()?
+    if (masterClock()->isClockAuto()) {
+        qDebug("auto select clock: audio > external");
+        if (!d->demuxer.audioCodecContext() || !d->ao || !d->ao->isOpen() || !d->athread) {
+            masterClock()->setClockType(AVClock::ExternalClock);
+            qDebug("No audio found or audio not supported. Using ExternalClock.");
+        } else {
+            qDebug("Using AudioClock");
+            masterClock()->setClockType(AVClock::AudioClock);
+        }
+    }
+    masterClock()->setInitialValue((double)absoluteMediaStartPosition()/1000.0);
+    // from previous play()
+    if (d->demuxer.audioCodecContext() && d->athread) {
+        qDebug("Starting audio thread...");
+        d->athread->start();
+    }
+    if (d->demuxer.videoCodecContext() && d->vthread) {
+        qDebug("Starting video thread...");
+        d->vthread->start();
+    }
+
+    d->read_thread->setMediaEndAction(mediaEndAction());
+    d->read_thread->start();
+
+    if (d->demuxer.audioCodecContext() && d->athread)
+        d->athread->waitForStarted();
+    if (d->demuxer.videoCodecContext() && d->vthread)
+        d->vthread->waitForStarted();
+    /// demux thread not started, seek tasks will be cleared
+    d->read_thread->waitForStarted();
+
+    /*if (!d->demuxer.isLoaded())
+        return;
+    d->start_position_norm = normalizedPosition(d->start_position);
+    d->stop_position_norm = normalizedPosition(d->stop_position);
+    // FIXME: if call play() frequently playInternal may not be called if disconnect here
+    disconnect(this, SIGNAL(loaded()), this, SLOT(playInternal()));
+    if (!d->setupAudioThread(this)) {
+        d->read_thread->setAudioThread(0); //set 0 before delete. ptr is used in demux thread when set 0
+        if (d->athread) {
+            qDebug("release audio thread.");
+            delete d->athread;
+            d->athread = 0;//shared ptr?
+        }
+    }
+    if (!d->setupVideoThread(this)) {
+        d->read_thread->setVideoThread(0); //set 0 before delete. ptr is used in demux thread when set 0
+        if (d->vthread) {
+            qDebug("release video thread.");
+            delete d->vthread;
+            d->vthread = 0;//shared ptr?
+        }
+    }
+
+    if (!d->read_thread->isRunning()) {
+        d->read_thread->start();
+        d->read_thread->waitForStarted();
+    }*/
+    d->read_thread->seek(0, QtAV::SeekType::AnyFrameSeek);
+    d->read_thread->pause(true, true);
+}
+
 AVClock* AVPlayer::masterClock()
 {
     return d->clock;
diff --git a/src/QtAV/AVPlayer.h b/src/QtAV/AVPlayer.h
index 9c58821..1984ab1 100644
--- a/src/QtAV/AVPlayer.h
+++ b/src/QtAV/AVPlayer.h
@@ -512,6 +512,8 @@ public slots:
     void setHue(int val);  //not implemented
     void setSaturation(int val);
 
+    void prebuffer();
+
 Q_SIGNALS:
     void bufferProgressChanged(qreal);
     void relativeTimeModeChanged();
@@ -571,6 +573,9 @@ Q_SIGNALS:
      */
     void internalSubtitleHeaderRead(const QByteArray& codec, const QByteArray& data);
     void internalSubtitlePacketRead(int track, const QtAV::Packet& packet);
+
+    void bufferingFinished();
+
 private Q_SLOTS:
     void loadInternal(); // simply load
     void playInternal(); // simply play
